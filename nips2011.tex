\documentclass{article} % For LaTeX2e
\usepackage{nips11submit_e,times}
%\documentstyle[nips10submit_09,times,art10]{article} % For LaTeX 2.09

\RequirePackage{amsfonts}
\RequirePackage{amsmath}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{proof}{Proof}
\newtheorem{conjecture}{Conjecture}

\newcommand{\suchthat}{ \mathrel{\ooalign{$\ni$\cr\kern-1pt$-$\kern-6.5pt$-$}}}

\title{A Hybrid Approach for Optimal Hierarchical Reinforcement Learning}


\author{
Hai-Feng Kao
Department of Computer Science\\
University of British Columbia\\
\texttt{haifeng@cs.ubc.ca}
}

% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to \LaTeX{} to determine where to break
% the lines. Using \AND forces a linebreak at that point. So, if \LaTeX{}
% puts 3 of 4 authors names on the first line, and the last on the second
% line, try using \AND instead of \And before the third author name.

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

%\nipsfinalcopy % Uncomment for camera-ready version

\begin{document}


\maketitle

\begin{abstract}
Model-based reinforcement learning makes an efficient use of samples by 
building the model of the environment and conducting the planning from the model,
thus it takes fewer samples to converge to the optimal policy.
Despite of the efficiency, model-based reinforcement learning 
suffers from the curse of dimensionality due to the fact that
the size of planning envelope grows exponentially with the number 
of features. In this paper, we propose an approximated model-based
approach to tackle this problem. By combining with 
hierarchically optimal recursive Q-learning (HORDQ) under 
the hierarchical reinforcement learning framework, we show that
the proposed approach converges to the optimal policy even when
the model is arbitrarily wrong.
\end{abstract}


%contribution: if the approximated model is good, it will converge faster than flat SARSA. 
%if not, it still converge eventually
%model-based approach is hard, they cannot figure out the correct Q value because the design of the model is biased
%model-free is ok because it doesn't require a model
%A fail safe mechanism to ensure that approximated model-based approach may
%converge to optimal policy even when the model is approximated
%converge even when our model is biased
%if the model worked--> converge to optimal policy fast
%if not, it will converge to the optimal policy anyway
%1. Motivate the purpose: 
   %0. the factered model is intrinsticly biased for non factored one
   %1. the power of model based approach (introduce the previous work and the lack of approximation)
   %2. previous work on approximated model based approach (2 actions and n steps is O(2^n))
   %2. previous work on model-based HRL
   %3. previous work on hybrid approach (no guaranntee on a approximated model) (all coarse to fine approach)
   %4. introduce HORDQ
   %5. the problem of HORDQ: worse than flat Q without transfer, our sol: add internal reward
   %6. our contribution: show that the important property is that it will converge to optimal policy for any planner
   %7. our contribution: combine with model-based approach (HORDQ is userful when we combine it with some approximated model)
   %8. a natural extension: use high internal reward in the beginning and decrease it in the end
   %Hierarchical Policy Gradient Algorithms
%2. Introduction on MAXQ
%3. Biased model
%4. HORDQ
%5. the leaf cover
%6. add all primitive actions and the necessary (and the price)
%5. show the optimality
%5.1. the offline case (not depend on Andre's proof)
%5.2. the online case (the conjecture status, how about chaning policy (value iteration)? --> define a new mdp)
%6. The three optimality (recursive optimality is not possible(model is approximated) bottom node recursive optimal is bad (always select get passenger),hierarchical optimality is impossible. the only hope is optimal)
%7. the respect of the hierarchy
%8. The experiment (school bus problem)
%9. The optimality cannot be achieved with recursive optimal (random planner with MAXQ --> the problem of existing approximation approach)
%10. With HORDQ, it is possible but slow (random planner with HORDQ)
%11. with appropriate penality it can be faster
%12. it works well if sometimes the model works and sometimes don't --> the agent can learn when to trust the planner (main contribution)
%12. why we don't use TAXI domain
%13. say that only model-free node has the Qe term

%show that hierarchical optimal policy becomes optimal policy when all primitive actions
%are available for all s in s_i
%the conjecture problem->another motivation why we need to focus on primitive actions
%The intuition is that the update rule for [] is actually the standard flat SARSA algorithm except that different subtasks have their own table.
%The intuition on QE (make subagent to rebel the hierarchy)
%Show that after modification, the hierarchical optimality can be achieved and it is equal to optimality

\section{Introduction}
The methods of model-based reinforcement learning learns a effective policy by 
by learning the model from samples and simulating experiences
from the model. It generally requires less samples to find the optimal policy. 
However, when the state space is too large, we cannot build the exact model anymore.
Instead, we have to approximate the transition probability function and 
reward function. Few works address the problem of model-based reinforcement learning
with approximation in an online setting.

Hester and Stone empirically compared on the effectiveness of 
approximation techniques with several reinforcement problems.
However, they didn't address the problem of generating 
new samples when the state space is too large to enumerate
all possible states.
Sutton et al. handled this problem by predicting the feature of the next state by linear function approximation.
Degris et al.  decision trees to learn a model of
Despite there effort, we note that 

supervised learning techniques to learn the model.
Sutton et al. handles by predicting the feature of the next state by linear function approximation.
Degris et al. 
Degris et al. [3] use decision trees to learn a model of
the MDP. A

We note that, however, for a stochastic environment, the size of planning envelope grows exponentially with the number of planning
steps. Predicting the next state is not enough since we may encounter different next states with the same state and action choice.
If we predict more than one states for each step, we will have a planning envelope which grows exponentially with the number of planning
steps. We need a way to restrict the size of planning envelope. Our idea is to separate the variables to planning variables 
and environment variables. We compute all of the possible values of planning variables, while assuming 
the environment variables to be static throughout the planning process.  
It seems that we over-simplifies the problem. Nevertheless, there are many applications
in which we can find some small set of variables which are more important than others. Take 
mobile robot navigation problem for example, 
what we concerned is the locaiton of the agent, 
for other slowing objects in surronding environment may not be a concerned 
Our contribution


There has been little previous work addressing planning
with linear function approximation in an online setting.

Our model seems over-simplified, however, there are some variables which are more 
infunential than others in many problems, it is reasonable to spend more resources
to model these variables. Take path for example.
Besides, a inevitable problem is the size of planning envelope. It 
We enumerate all possible states.
we separate the varible into planning variable and environment variables.
We only model the transition for planning varialbe and assuming environment variables are
static throughout the planning process.
One motivation application is the navigation problem. In navigation task,
what we concerned is the locaiton of the agent, 
for other slowing objects in surronding environment may not be a concerned 
since they do not have significant impact on our plan
Thus we can assign the location
as the planning variable and keep the rest of the information as environment variable.
With the approximation, we can significatly reduce the size of the planning envelope.
We don't have the trouble 
Hester and Stone provides an empirical comparison on several popular 
supervised learning techniques to learn the model.
Sutton et al. handles by predicting the feature of the next state by linear function approximation.
Degris et al. 
Degris et al. [3] use decision trees to learn a model of
the MDP. A
A separate decision tree is built to predict each
next state feature as well as the reward. Their algorithm
attempts to predict the absolute transition function, while
our approach is to predict the relative effects of transitions,
which may be easier in many domains. Degris et al.’s algo-
rithm calculates an ǫ-greedy policy through value iteration
based on the model provided by the decision trees.




Instead, we need a approximated model

There has been little previous work addressing planning
with linear function approximation in an online setting.
Paduraru (2007) treated this case, focusing mainly on sampling
stochastic models of a cascading linear form, but
also briefly discussing deterministic linear models. Degris,
Sigaud and Wuillemin (2006) developed a version of Dyna
based on approximations in the form of dynamic Bayes networks
and decision trees. Their system, SPITI, included
online learning and planning based on an incremental version
of structured value iteration (Boutilier, Dearden &
Goldszmidt 2000).




Reinforcement learning (RL) studies the problem of
finding effective solutions to sequential decision mak-
ing problems (Sutton & Barto, 1998). For many
agent-based applications, it is critical that an RL al-
gorithm be very sample efficient: that it takes very
few actions to learn an effective policy. We focus on
sample efficiency as the key evaluation criterion for
RL algorithms because in many agent-based applica-
tions, acquiring experiences can be very expensive and
time-consuming. Two of the main approaches towards
this goal are to incorporate generalization (function
approximation) into model-free methods and to de-
velop model-based algorithms. Model-based methods
achieve high sample efficiency by learning a model of
the domain and simulating experiences in their model,
thus saving precious samples in the real world.
This paper is motivated primarily by the observation
that the world is too large to explore exhaustively.
Consider, for example, the act of identifying your fa-
vorite restaurant. One possible strategy is to visit the
restaurants in order of their distances from your house,
visiting closest ones first. In most American cities, do-
ing so would likely lead you to visit several pizza par-
lors, fast food joints, and coffee shops before getting to
many gourmet establishments. Nonetheless, provided
that you have time to try every restaurant, eventually
you will find your favorite one.

The first of these advances is model-based RL. Early work in this direction
demonstrated that summarizing an agent’s experience into a model facilitates
the efficient reuse of data [1]. Later work investigated how the uncertainty in
the model can guide exploration, yielding the first (probabilistic) finite bounds
on the amount of data required to learn near-optimal behaviors [2,3]. Still, these
guarantees require that the agent exhaustively explore every state. Particularly
in large domains, this exploration can be impractical.
Third, hierarchical decomposition is perhaps the most intuitively appealing
extension of the standard approach, since we would like to imbue our learning
algorithms with the same awareness of structure that seems to allow us to
cope with the extraordinary complexity of the real world. Hierarchical RL has
been explored via work on temporal abstraction, in which temporally extended
abstract actions allow agents to reason above the level of primitive actions [6].
However, we still do not have a complete understanding of how hierarchy benefits
learning and therefore how to design or discover hierarchies.

Second, function approximation allows RL to cope with large or even infinite
state spaces by introducing generalization. It allows an algorithm to approximate
the long-term value of every action in every state using only a relatively
small set of parameters. Many state-of-the-art approaches employ model-free
algorithms and representations that attempt to estimate these values directly
from data [4,5], but they often st

Reinforcement learning studies the problem
of solving sequential decision making prob-
lems. Model-based methods learn an effec-
tive policy in few actions by learning a model
of the domain and simulating experience in
their models. Typical model-based methods
must visit each state at least once, which
can be infeasible in large domains. To over-

Each interaction provides additional
information that can be used to learn a better model of the
world’s dynamics, and because this change could result in a
different action being best (given the model), the planning
process should be repeated to take this into account. However,
planning is inherently a complex process; on large
problems it not possible to repeat it on every time step without
greatly slowing down the response time of the system.

\cite{approxModel}
There has been little previous work addressing planning
with linear function approximation in an online setting.
Paduraru (2007) treated this case, focusing mainly on sampling
stochastic models of a cascading linear form, but
also briefly discussing deterministic linear models. Degris,
Sigaud and Wuillemin (2006) developed a version of Dyna
based on approximations in the form of dynamic Bayes networks
and decision trees. Their system, SPITI, included
online learning and planning based on an incremental version
of structured value iteration (Boutilier, Dearden &
Goldszmidt 2000).

The factored Markov Decision Process (FMDP) is a formalism for sequential decision problems
that allows for the explicit representation of environmental structure not possible in the traditional
Markov Decision Process (MDP). Much work in the reinforcement learning literature has focused
on algorithms that exploit this structure to more efficiently learn or compute optimal solutions to
such problems [1, 2]. In some cases this has allowed for the application of reinforcement learning
techniques to environments much larger than could otherwise be handled feasibly by methods that
do not exploit structure. These approaches generally make use of structure by ignoring regions or
entire dimensions of the state space that are irrelevant to solving a particular task. Many of these
approaches make use of factored transition and reward models to represent these independencies.
The majority of work with FMDPs has focused on discrete environments; i.e., those with a finite
number of states and actions. Some of these approaches have presented methods for learning a
factored transition model online from experience, and for using that model to compute optimal
policies [3, 4, 5].

Each interaction provides additional
information that can be used to learn a better model of the
world’s dynamics, and because this change could result in a
different action being best (given the model), the planning
process should be repeated to take this into account. However,
planning is inherently a complex process; on large
problems it not possible to repeat it on every time step without
greatly slowing down the response time of the system.


Reinforcement learning studies the problem
of solving sequential decision making prob-
lems. Model-based methods learn an effec-
tive policy in few actions by learning a model
of the domain and simulating experience in
their models. Typical model-based methods
must visit each state at least once, which
can be infeasible in large domains. To over-
come this problem, the model learning algo-
rithm needs to generalize knowledge to un-
seen states and provide information about
the states in which it needs more experi-
ence. In this paper, we use existing super-
vised learning techniques to learn the model
of the domain. We empirically compare their
effectiveness at generalizing knowledge across
states on three different domains. Our results
indicate that tree-based models perform the
best after training on a small number of tran-
sitions, while support vector machines per-
form the best after a large number of transi-
tions.
1.


%say the benefit of model-based RL (peter's model based HRL, 
%illustrate the problem of model-based RL

%show that it can be resolved by HRL
%say other HRL work, but no one addresses the optimality with biased model

At higher level, we use model-based approach to do the planning on a coarser state representation. 
At lower level, model-free approach is used....
[Ditterich did that as well]
Instead of focusing on safe state abstraction, we are more interested in the unsafe one.
The state of real world problem can be very large and complicated, we may 
not always find a safe abstracition. In this work, we show that the 
optimality can still be achieved if 1. 2. 
[CMU TR][] some uses (unsafe) corasers state at higher level, but none of them 
provide any guarrante the optimality when the coarser representation are
not safe, 

None of the previous approaches 

\section{Model formulation}

\begin{definition} Markov decision process is formalized as a tuple $<S, A, P, R>$, where
\begin{itemize}{}
\item $S$ is a finite set of states of the environment.
\item $A$ is a finite of actions.
\item The transition function $P:S \times A \times S \rightarrow [0, 1]$ defines a probability distribution over the possible next states. 
\item The reward function $R:S \times A \rightarrow \mathbb{R}$ defines the reward after executing a certain action at a certain state.
\end{itemize}
\end{definition}

Given a state of the environment, a policy $\pi: S \times A$ tells what action should be performed at that state. 
The value function $V^{\pi}: S \times \mathbb{R}$ is the expected cumulative reward when executing
policy $\pi$ from state $s$.

The value function satisfies the Bellman equation:
\begin{equation}
    V^{\pi}(s) = \sum_{s'}P(s'|s, \pi(s))[R(s, \pi(s)) + \gamma V^{\pi}(s')],
    \label{eq:V}
\end{equation}
where $\gamma \in [0, 1]$ is the discount factor which discounts the future reward to the present value.

Similarly, we define the action-value function (or Q function) as:
\begin{equation}
    Q^{\pi}(s, a) = \sum_{s'}P(s'|s, a)[R(s, a) + \gamma Q^{\pi}(s', \pi(s'))].
    \label{eq:Q}
\end{equation}
The Q function is the expected cumulative reward after executing action $a$ at state $s$ and following
$\pi$ thereafter.

Now lets us extends action set $A$ to include composite actions.

The transition function $P$ and $R$ are modified to include the time to accomplish each composite action:
\begin{equation}
    P(s'|s, a) = \sum^{\infty}_{k=1} \gamma^k Pr(k, s'|s, a),
    \label{eq:multiProb}
\end{equation}
\begin{equation}
    R(s, a) = \sum^{\infty}_{k=0} \gamma^k r_k
\end{equation}

%The value function needs to be modified as:
%\begin{equation}
    %V^{\pi}(s) = \sum_{s'}P(s'|s, \pi(s))[R(s, \pi(s), t) + \gamma^N V^{\pi}(s')],
%\end{equation}
%where $N$ is the number of steps for the action $\pi(s)$ to finish its execution.
%A question arises since we do not know the actual time to finish executing each composite action.
%Let's set $gamma=1$ from now on.
%TODO: (how MaxQ solve it?).

As in MAXQ, a task hierarchy such as the one illustrated above can be modeled by
decomposing the overall task MDPM, into a finite set of subtasks fM0;M1; : : : ;Mm􀀀1g,
where M0 is the root task. Solving M0 solves the entire MDPM.
Definition 3.1: Each non-primitive subtask Mi (Mi is not a primitive action) consists
of five components (Si; Ii; Ti;Ai;Ri):

In this work, we follow the MaxQ hierarchy defined in \cite{MaxQ}:
\begin{definition}
    Given a MDP $M$, the hierarchical reinforcement learning decomposes $M$ into a finite
    set of subtasks $M = {M_0, M_1, \dots, M_n}$, where $M_0$ is the root subtask. 
    Each subtask is defined by 3 tuples $<T_i, A_i, \tilde{R}_i>$. 
    \begin{itemize}{}
    \item $T_i$ is a termination predicate. It partitions state space $S$ into active states $S_i$ and
                terminal states $T_i$. If subtask $M_i$ enters any terminal states, it terminates immediately
                and return the control to the parent subtask. A parent subtask cannot execute the subtask
                $M_i$ if the current state belongs to $T_i$.
    \item $A_i$ is a set actions which are available to subtask $M_i$. An action can be either primitive or composite.
                If it is composite, it pass execution to the corresponding subtask. No recursive calls 
                are allowed in the hierarchy.
    \item $\tilde{R}_i$ is the pseudo reward function 
    \end{itemize}
\end{definition}
A hierarchical policy $\pi = \{\pi_1, \pi_2, \dots, \pi_n\}$ is a set which contains all subtask policies. 
The subtask policy $\pi: S_i \rightarrow A_i$ maps an active state to one of the actions to execute.

Fig. \ref{fig:Maze} shows a simple maze problem introduced by Dietterich \cite{MaxQJ}.
The agent has 4 primitive actions: North, South, East, West, and two composite actions: GotoExit and GotoGoal.
The 
GotoExit terminates when the agent exits the left room. GotoGoal terminates when the agent achieves to the goal.
Each primitive leads to -1 reward to the agent.


In Dietterich's work, all Max nodes are model-free. 
So let us proceed by changing "MaxRoot" node to the model-based one, and let "MaxExit"and "MaxGoal"
to be the regular model-free Max node.
The task for the $i$-th model-based Max node is to compute:
\begin{equation}
    Q^{\pi}(i, s, a) = V^{\pi}(a, s) + C^{\pi}(i, s, a),
\end{equation}
where the completion function $C^{\pi}(i, s, a)$ is the expected cumulative reward after
we complete (composite) action $a$ at state $s$ and before the termination of $i$-th Max node.
$V^{\pi}(a, s)$ is the 
expected cumulative reward when we execute action $a$ at state $s$.
The value $Q^{\pi}(i, s, a)$ is stored in the corresponding Q node.
For example, $Q^{\pi}(MaxRoot, s, GotoExit)$ is stored in "QExit" node.

The node queries its children node to get the value of $V^{\pi}(a, s)$.
It can be computed by:
\begin{equation}
    V^{\pi}(i, s) = \left\{\begin{array}{ll}
                    Q^{\pi}(i, s, \pi_i(s)) & \mbox{if i is composite} \\
                    \sigma_{s'} P(s'|s, i)R(s'|s, i) & \mbox{if $x>y$} \\  
                    \end{array} \right.
    \label{eq:V}
\end{equation}
In our example, to compute $Q^{\pi}(MaxRoot, s, GotoExit)$, "MaxRoot" node would query 
"MaxExit" node to get $V^{\pi}(GotoExit, s)$.

The $C^{\pi}(i, s, a)$ can be computed by the model:
\begin{equation}
    C^{\pi}(i, s, a) = \sum_{s', N}P(s', N|s, \pi(s))\gamma^N[Q^{\pi}(i, s', \pi(s'))].
    \label{eq:C}
\end{equation}

Note that $P(s'|s, \pi(s))$ and $V^{\pi}(a, s)$ are provided by the child Max nodes.

For model-based child Max nodes, $P(s'|s, \pi(s))$ can be computed by equation \ref{eq:multiProb}.

For primitive Max nodes, it can be estimated by:
\begin{equation}
    \tilde{P}(s'|s, a)  = \frac{n(s', s, a)}{n(s, a)},
    \label{eq:countP}
\end{equation}
where $n(s, a)$ is the number of times primitive action $a$ executed 
at state $s$. $n(s', s, a)$ is the number of times primitive action $a$
transitioned the agent from state $s$ to $s'$.

For model-free Max nodes, it can be estimated by \cite{option}:
\begin{equation}
    \tilde{P}(x|s, a) = (1-\alpha)\tilde{P}(x|s, a) + \alpha [ \gamma^N \delta_{s'x}],
    \label{eq:approxP}
\end{equation}
where $s'$ is the observed state after composite action $a$ is executed at state $s$.
$k$ is the number of steps for action $a$ to finish. 
$x$ is the terminal state for the model-free Max node. $\delta_{s'x}=1$ if observed state $s'$
is terminal state $x$ and 0 otherwise.
$\alpha$ is the step-size parameter.
The update of equation \ref{eq:approxP} is conducted after action $a$ terminates at some terminal state,
so we know the exact value of $k$. Note that all of terminal states of the Max node shall be updated after 
action $a$ finished.

We can also use equation \ref{eq:countP} to estimate $\tilde{P}(x|s, a)$, but the policy of the Max node
might change, so equation \ref{eq:approxP} is a better choice.

\section{State Abstraction for model-based Max nodes}
\label{se:Model}
The idea behind model-based approach is to use the sample data to build the model of the environment
and conduct the planning from the model.
The advantage of model-based approaches is that they make more efficient use of the sample data, thus 
it take fewer time to train a model-based RL agent.

The disadvantage is that it needs to compute Q value of all state-action pairs in the current 
planning envelope by Bellman equation (equ. \ref{eq:Q}) until convergence.
Since the number of state-action pairs grows exponentially with the number of features,
it quickly becomes computationally intractable for both time and memory.
For a problem with 9 binary features, the number of states can be $O(2^9)$ and the
number of state-action pairs $(s, a, s')$ can be as large as $2^(9+1+9)=2^19$, which cannot be fit into the
memory of modern computers.

To apply model-based reinforcement learning to large scale problems, 
we need to use some state abstraction technique to reduce the size of planning envelope.

We begin by constructing a projection function $proj(s)$ (it always exists, why?),
which projects state $s$ to an action-invariant space.
That is:
\begin{equation}
    \forall P(s'|s, a) > 0, proj(s') = proj(s)
\end{equation}
It means that the projected state does not change after the execution of 
any actions.
We also needs its dual function $\bar{proj}(s)$ to reconstruct 
the original state $s = \phi(proj(s), \bar{proj}(s))$.

Now we can model $P(s'|s, a)$ by:
\begin{equation}
    P(s'|s, a) = P(\bar{proj}(s')| \bar{proj}(s), proj(s), a)
\end{equation}

Note that we need to query $P(s'|s, a)$ from the child nodes with original representation.
Thus, $\phi(ps, \bar{ps})$ is adopted to compute the original $s'$.  

Although the state abstraction technique above provides us compact state representation, 
it doesn't change the size of the planning envelope. Thus we do not gain any computational
advantage by applying such an abstraction technique.

A key observation of this work is to adopt the approximated projection function which
does not project state $s$ to an action-invariant space.
The size of planning envelope grows exponentially with the number of features.
By assuming 
some features do not change during the execution of actions, we do gain computational advantage by
significantly reducing the size of the planning envelope. 
We lose the optimally with this approximation technique, but it is necessary because we want 
to apply our work beyond toy applications.
Our approach doesn't imply that
some features are completely ignored. The agent still computes the plan according to 
the full state information, but the transition model is simplified to only include the 
relevant information.

\section{Hierarchically optimal recursive Q-learning (HORDQ)}
1. linear approximation (good for model-free approach)
2. the update rule (only on other model-free nodes)

\section{The optimality criterion}

There are no theoretical guarantee for the model-based approach introduced in previous 
section. The performance depends on the selection of planning variables. In the worst
case, the policy can go very wrong. It makes recursive optimality impossible, since
the approach may not converge to the optimal policy within the subtask. Likewise,
a suboptimal policy for a subtask may also make hierarchical optimality impossible.
Here we are looking for a certain hierarchy  

%3.3 Local versus Global Optimality
%Using hierarchy reduces the size of the space that must be searched to find a good policy.
%However, a hierarchy constrains the space of possible policies so that it may not be
%possible to represent the optimal policy or its value function, and hence make it impossible
%to learn the optimal policy. If we cannot learn the optimal policy, the next best target
%would be to learn the best policy that is consistent with the given hierarchy. Two notions of
%optimality have been explored in the previous work on hierarchical reinforcement learning,
%hierarchical optimality and recursive optimality (Dietterich, 2000).
%Definition 3.3: A hierarchical optimal policy for MDP M is a hierarchical policy which
%has the best performance among all policies consistent with the given hierarchy. In other
%words, hierarchical optimality is a global optimum consistent with the given hierarchy. In
%this form of optimality, the policy for each individual subtask is not necessarily optimal,
%but the policy for the entire hierarchy is optimal. The HAMQ HRL algorithm (Parr, 1998)
%and the SMDP Q-learning algorithm for a fixed set of options (Sutton et al., 1999; Precup,
%2000) both converge to a hierarchically optimal policy. 
%Definition 3.4: Recursive optimality, first introduced by Dietterich (2000), is a weaker
%but more flexible form of optimality which only guarantees that the policy of each subtask
%is optimal given the policies of its children. It is an important and flexible form of
%optimality because it permits each subtask to learn a locally optimal policy while ignoring
%the behavior of its ancestors in the hierarchy. This increases the opportunity for subtask
%47
%sharing and state abstraction. The MAXQ-Q HRL algorithm (Dietterich, 2000) converges
%to a recursively optimal policy.

\section{Optimality with Biased Model}
The primary contribution of this work is to show that by combining model-based and 
model-free approaches, we can still achieve optimality even when the model is biased.
%Andre and Russell \cite{OptimalQ} extends MaxQ framework to be hierarchical optimal.
%They defined $Q_E(i, s, \pi(s))$ as:
%\begin{equation}
    %Q_E^{\pi}(i, s, \pi(s)) = \Sigma_N \Sigma_{x \in T_i}P(x, N| s, \pi(s)) \gamma^N Q^{\pi}(x, \pi(x)).
    %\label{eq:QE}
%\end{equation}
%$Q_E^{\pi}(i, s, \pi(s))$ is the expected cumulative reward after $i$-th node follows 
%policy $\pi$ at state $s$ and terminates at some point.

\begin{definition}
    Give a hierarchical policy $\pi$ and state $s$, an execution path $E_p^\pi(a_0, s)$ 
    is a set of actions $\{a_0, a_1, \dots, a_{n-1}\}$, where $a_1=\pi_{a_0}(s), a_2=\pi_{a_1}(s), \dots$,
    and $\pi_{a_{n-1}}(s)$ is a primitive action.
\end{definition}
The execution path tells us the order of subtasks which will be invoked for state $s$.


\begin{definition}
    $\mathbb{C}(H) = \{N_1, N_2, \dots, N_k\}$ is a leaf cover of hierarchy $H$ if 
    there exists a composite action $a \in E_p^{\pi}(0, s)$, which belongs to $\mathbb{C}(H)$ for every
    state $s$ and every hierarchical policy $\pi$.
    Furthermore, $\mathbb{C}(H)$ is a total leaf cover if all primitive actions are available for every 
    subtasks $N_i \in \mathbb{C}(H)$.
\end{definition}


%TODO: not all s are defined in Q(i, s, a) (focus on si instead of all i)
%TODO: what if pi_c_bar may change for every step?
%TODO: what if pi_c_bar is not deterministic
%TODO: write down the Q learning algorithm and the model-based one
%TODO: why Q^*(i, s, a) = Q^*(s, a) shows that hierarchical pi is the optimal policy
%TODO: any rigorous property for leaf cover?
%TODO: do I use all assumption for the theorem?
%TODO: the relationship between HORDQ and my approach
%TODO: provide the reason why we need to acceess all primitive action (because of the dumb and never learn planner)
%TODO: show that I can convert any MDP problem to hierarchy one, thus we can always combine approximated model-based approach with HORDQ.

\begin{theorem}
    If $\mathbb{C}(H)$ is a total leaf cover, we have $Q^*(i, s, a) = Q^*(s, a), \forall i \in \mathbb{C}(H)$
\end{theorem}
\textbf{Proof:} Let $\pi_{\bar{\mathbb{C}}}: \mathbb{C}(H) \times S \rightarrow \mathbb{C}(H)$ be the policy to invoke
the next subtask $j = \pi_{\bar{\mathbb{C}}}(i, s)$ which belongs to $\mathbb{C}(H)$. It is determined
by the policy of subtasks which do not belong to $\mathbb{C}(H)$ and terminate predicate $T_i$. Follow Bellman's equation, we have:
\begin{align}
    Q^{\pi}(i, s, a) &= \sum_{s'} P^{\pi}(\pi_{\bar{\mathbb{C}}}(i, s'), s'|i, s, a) [R(s', s, a) + \gamma Q^{\pi}(\pi_{\bar{\mathbb{C}}}(i, s'), s', \pi_i(s'))]\\
    &=\sum_{s'}P^{\pi}(\pi_{\bar{\mathbb{C}}}(i, s')| i, s, a, s') P(s' | i, s, a)  [R(s', s, a) + \gamma Q^{\pi}(\pi_{\bar{\mathbb{C}}}(i, s'), s', \pi_i(s'))]\\
    &\mbox{since $\pi_{\bar{\mathbb{C}}}$ is a deterministic policy}\\
    &=\sum_{s'} P(s' | s, a) [R(s', s, a) + \gamma Q^{\pi}(\pi_{\bar{\mathbb{C}}}(i, s'), s', \pi_i(s'))]
    \label{eq:MaxIrr}
\end{align}

Compare to the Bellman equation of the flat MDP:
\begin{equation}
    Q^{\pi_f}(s, a) = \sum_{s'}P(s'|s, a)[R(s', s, a) + \gamma Q^{\pi_f}(s', \pi_f(s'))].
    \label{eq:bellman}
\end{equation}

The equations \ref{eq:MaxIrr} and \ref{eq:bellman} are identical except for the Q values.
Due to uniqueness of Bellman equation, if $\pi_i(s) = \pi_f(s), \forall s$, we will have $Q^{\pi_f}(s, a) = Q^{\pi_f}(i, s, a)$. 
If $\pi_i(s) = \pi^*_f(s)$, $Q^*(s, a)$ is a solution and also an optimal solution (why?) of equation \ref{eq:MaxIrr}.
Thus we have $Q^*(i, s, a) = Q^*(s, a)$. \textbf{Q.E.D.}

%\begin{definition}
    %$\mathbb{C}(H) = \{N_1, N_2, \dots, N_k\}$ is a leaf cover of MaxQ hierarchy $H$ if 
    %we can divide H into several disjoint partitions $P = \{P_1, \dots P_m\}$ after removing all nodes in $\mathbb{C}(H)$.
    %And the root node does not share the partition with any leaf nodes. 
    %$\exists N_i \in \mathbb{C(H)} \suchthat N_i$ is an ancestor of $l$.
%\end{definition}

%\begin{definition}
    %A subtask policy $\pi_i$ is optimal if $\pi_i^{hg*}(s)=\pi_p^*(s) \forall s \in S_i$,
    %where $\pi_p^*(s)$ is the flat optimal policy.
%\end{definition}


%\begin{theorem}
    %If the corresponding subtask policy $\pi_i$ is optimal $\forall N_i \in \mathbb{C}(H)$,
    %the policy $\pi_j$ of the ancestor of $N_i$ is also optimal for all possible $\pi_j$.
%\end{theorem}
%Proof: $\forall N_j$: the ancestor of some node $\in \mathbb{C}(H)$, policy $\pi_j(s)$ would invoke some 
%node $N_i$ and execute its policy $\pi_i^{hg*}(s)$. Since the policy is optimal, $\pi_j^{hg*}(s)=\pi_p^*(s)$.

%\begin{center}
%\begin{tabular}{@{}lp{6cm}@{}}
%\hline
%Algorithm: ExecuteHGPolicy\\
%\hline
%Initialize $\hat{Q_0}$ arbitrarily\\
%$t \leftarrow 0$\\
%Repeat (for each episode)\\
%\ \ \ \ \ \ Initialize $s$\\
%\ \ \ \ \ \ Choose $a$ based on $s$ using policy derived from $\hat{Q_t}$ (e.g., $\epsilon$-greedy method)\\
%\ \ \ \ \ \ Repeat (for each step of episode):\\
%\ \ \ \ \ \ \ \ \ \ \ \ Take action $a$, obtain reward $r$ and next state $s'$ from the environment\\
%\ \ \ \ \ \ \ \ \ \ \ \ Choose $a'$ based on $s'$ using policy derived from $\hat{Q_t}$ (e.g., $\epsilon$-greedy method)\\
%\ \ \ \ \ \ \ \ \ \ \ \ $\hat{q_t} \leftarrow \hat{Q_t}(s, a) + \alpha [r + \gamma \hat{Q_t}(s', a')-\hat{Q_t}(s, a)]$ \\
%\ \ \ \ \ \ \ \ \ \ \ \ Update $\hat{Q_t}$ with $(s, a, \hat{q_t})$ by online L1 regression to produce $\hat{Q_{t+1}}$\\
%\ \ \ \ \ \ \ \ \ \ \ \ $s \leftarrow s'$\\
%\ \ \ \ \ \ \ \ \ \ \ \ $a \leftarrow a'$\\
%\ \ \ \ \ \ \ \ \ \ \ \ $t \leftarrow t+1$\\
%\ \ \ \ \ \ Until $s$ is terminal\\
%\hline  
%\end{tabular}
%\end{center}

%Note that Q function is:
%\begin{align}
    %Q^{\pi}(s, \pi(s)) &= Q^{\pi}(i, s, \pi(s)) + Q_E^{\pi}(i, s, \pi(s))\\
    %&= V^{\pi}(\pi(s), s) + C^{\pi}(i, s, \pi(s)) + Q_E^{\pi}(i, s, \pi(s))
%\end{align}

%Andre and Russell then prove:
%\begin{theorem}
    %If $V^{*}, C^*, Q_E^*$ are solutions to equation \ref{eq:V}, \ref{eq:C},
    %and \ref{eq:QE} for $\pi^*$, then $Q^* = V^{*} + C^* + Q_E^*$ is a solution
    %to the standard Bellman equation.
%\end{theorem}
%\begin{theorem}
    %Decomposed value iteration and policy iteration algorithms derived from equation
    %\ref{eq:V}, \ref{eq:C}, and \ref{eq:QE} converge to $V^{*}, C^*, Q_E^*$, and $\pi^*$.
%\end{theorem}

%However, we need something stronger:
%\begin{theorem}
    %Let $\mathbb\{C\} = \{N_1, N_2, \dots\}$. If 
    %(a) $\forall N_i \in \mathbb{C}$, the descendants of Max node $N_i$ covers all primitive Max nodes
    %and (b) for all path from root node to leaf node must pass at least one of the nodes in $\mathbb{C}$,
    %then the agent has hierarchical optimal policy $\pi^*$ when the policy of node $j \in \{j | j \in subtree(N_i), \forall N_i \in \mathbb{C}\}$.
%\end{theorem}

In Fig. \ref{fig:MazeH}, the agent has an hierarchical optimal policy when "MaxGoal" and "MaxExit"
have the hierarchical optimal policy regardless of the policy of "MaxRoot".

If we let all nodes which are the parent of some primitive Max nodes to have access
to all primitive actions, we can construct $\mathbb{C}$ by including all 
such nodes. Since the optimal policy does not depend on any nodes not in $\mathbb{C}$, 
we can safely replace all such nodes by our approximated model-based nodes.

For example, if we replace "MaxRoot" with approximated model-based nodes,
the policy is still optimal. 

The problem of this hierarchical optimal approach is that policy $\pi_i$ of $i$-th
node is determined by the expected cumulative reward, not by the expected pseudo reward as
MaxQ. Due to the lack of pseudo reward, each subtask $M_i$ lacks the motivation to 
pursue the goal state defined by the hierarchy, thus it makes the hierarchical 
design useless. 
It is necessary to add some pseudo reward to encourage each subtask to pursue 
the goal. Nevertheless, it should be done carefully, otherwise we will lose
the optimality.

Here we show a way to add the pseudo reward without violating the hierarchical 
optimal constraint:
\begin{theorem}
    Let $x$ be some terminal state of subtask $M_i$, $R(x)$ be the reward
    when the agent arrives state $x$, $\tilde{R}(x) = R(x) - r$ be the pseudo reward
    and $r$ be the penalty term.
    If $P(x| s, \pi_i^*(s)) = 0$, we have $Q^*(i, s, \pi^*(s)) = \tilde{Q}^*(s, \tilde{\pi}(s))$.
\end{theorem}

The above theorem says that the optimal policy does not change 
if some penalty is applied at some terminal states which are not part of the optimal path.


%We need the penalty for the hierarchy to work. 
%Since we do not usually know what the optimal policy is, we may add penalty term in 
%wrong states and lose the optimality. But we do not always require 


The idea of our work is to use the approximated model-based node to 
compute the plan for the agent, and let the hierarchical optimal model-free node
to execute the plan. If everything works as the plan, the agent would converge to the optimal
policy in a short time. If not (following the plan is worse than the penalty term),
the model-free node will take control and find the optimal policy on its own.

The penalty term serves as a mechanism to enforce the subtask to follow the hierarchy.
The subtask will strictly follow the subgoal defined by the hierarchy if the penalty term is large.
On the other hand, if the penalty term is small, the subtask is more likely to go rouge and try to 
solve the whole problem on its own. Here we have a engineering decision: if we trust our hierarchy design, 
we should increase the penalty term to let the agent find the optimal policy as fast as it can; 
if not, a low penalty term allows the agent to find the optimal policy when the hierarchy doesn't work.


\subsection{Figures}

All artwork must be neat, clean, and legible. Lines should be dark
enough for purposes of reproduction; art work should not be
hand-drawn. The figure number and caption always appear after the
figure. Place one line space before the figure caption, and one line
space after the figure. The figure caption is lower case (except for
first word and proper nouns); figures are numbered consecutively.

Make sure the figure caption does not get separated from the figure.
Leave sufficient space to avoid splitting the figure and figure caption.

You may use color figures. 
However, it is best for the
figure captions and the paper body to make sense if the paper is printed
either in black/white or in color.
\begin{figure}[h]
\begin{center}
%\framebox[4.0in]{$\;$}
\fbox{\rule[-.5cm]{0cm}{4cm} \rule[-.5cm]{4cm}{0cm}}
\end{center}
\caption{Sample figure caption.}
\end{figure}

\subsection{Tables}

All tables must be centered, neat, clean and legible. Do not use hand-drawn
tables. The table number and title always appear before the table. See
Table~\ref{sample-table}.

Place one line space before the table title, one line space after the table
title, and one line space after the table. The table title must be lower caseggg
Systems 7}, pp. 609-616. Cambridge, MA: MIT Press.

[2] Bower, J.M. \& Beeman, D. (1995) {\it The Book of GENESIS: Exploring
Realistic Neural Models with the GEneral NEural SImulation System.}
New York: TELOS/Springer-Verlag.

[3] Hasselmo, M.E., Schnell, E. \& Barkai, E. (1995) Dynamics of learning
and recall at excitatory recurrent synapses and cholinergic modulation
in rat hippocampal region CA3. {\it Journal of Neuroscience}
{\bf 15}(7):5249-5262.
}

{\small
\bibliographystyle{plain}
\bibliography{biblio}
}
\end{document}
